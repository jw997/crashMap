<!doctype html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<style>
		.info {
			padding: 6px 8px;
			font: 14px/16px Arial, Helvetica, sans-serif;
			background: white;
			background: rgba(255, 255, 255, 0.8);
			box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
			border-radius: 5px;
		}

		.info h4 {
			margin: 0 0 5px;
			color: #777;
		}

		.legend {
			line-height: 18px;
			color: #555;
		}

		.legend i {
			width: 18px;
			height: 18px;
			float: left;
			margin-right: 8px;
			opacity: 0.8;
		}

		.box {
			border: 2px dotted rgb(96 139 168);

			display: flex;
			flex-direction: row;
		}

		.box div {


			background-color: rgb(96 139 168 / 0.2);
			border: 2px solid rgb(96 139 168);
			border-radius: 5px;
		}

		#query_stuff {

			width: 400px;
			flex: none;
			border: 1px solid black;
		}

		#osm-map {
			flex: 1 1 0px;
			border: 1px solid black;
		}

		#selectStreet {
			display: block;
		}
	</style>
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
	<link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet" />
	<!---	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.min.js"></script> -->

</head>

<body class="sansserif">
	<div class="box">
		<div id="query-stuff">
			<!----	<input type="checkbox" id="checkBike" name="vehicle1" value="Bike">
			<label for="checkBike">Bicycle</label><br>
			<input type="checkbox" id="checkCar" name="vehicle2" value="Car">
			<label for="checkCar">Car</label><br>
			<input type="checkbox" id="checkPed" name="vehicle3" value="Ped">
			<label for="checkPed">Pedestrian</label><br>

			<input type="checkbox" id="checkTruck" name="vehicle3" value="Ped">
			<label for="checkTruck">Truck</label><br>

			<input type="checkbox" id="checkParked" name="vehicle3" value="Ped">
			<label for="checkParked">Parked Vehicle</label><br>

			<input type="checkbox" id="checkMotorcycle" name="vehicle3" value="Ped">
			<label for="checkMotorcycle">Motorcycle</label><br>

			<input type="checkbox" id="checkBus" name="vehicle3" value="Ped">
			<label for="checkBus">Bus</label><br>

			<input type="checkbox" id="checkElectricScooter" name="vehicle3" value="Ped">
			<label for="checkElectricScooter">Electric Scooter</label><br>
--->
			<select id="selectVehicleTypes">
				<option value='.*'>Any</option>
				<option value='Car'>Car/Any</option>
				<option value='Bi.*Car'>Car/Bicycle</option>
				<option value='Car.*Ped'>Car/Pedestrian</option>
				<option value='Car.*Solo|Car.*Object'>Car/Solo</option>


				<option value='Bi'>Bicycle/Any</option>
				<option value='Bi.*Ped'>Bicycle/Pedestrian</option>
				<option value='Bicyle$|Bi.*Solo'>Bicycle/Solo</option>

				<option value='Ped'>Pedestrian/Any</option>

				<option value='Electric Bi'>Electric bicycle/Any</option>
				<option value='Electric Bi.*Ped'>Electric bicycle/Pedestrian</option>
				<option value='Electric Sc'>Electric Scooter/Any</option>
				<option value='Electric Sc.*Ped'>Electric Scooter/Pedestrian</option>
				<option value='Electric Skate'>Electric Skateboard/Any</option>
				<option value='Electric Skate.*Ped'>Electric Skateboard/Pedestrian</option>

				<option value='Motor'>Motorcycle/Any</option>
				<option value='Motor.*Car'>Motorcycle/Car</option>

				<option value='Truck'>Truck/Any</option>

				<option value='Bus'>Bus/Any</option>
			</select>
			<br />
			<input type="checkbox" id="check2024"> <label for="check2024">2024</label><br>
			<input type="checkbox" id="check2023"> <label for="check2023">2023</label><br>
			<input type="checkbox" id="check2022"> <label for="check2022">2022</label><br>
			<input type="checkbox" id="check2021"> <label for="check2021">2021</label><br>
			<input type="checkbox" id="check2020"> <label for="check2020">2020</label><br>
			<input type="checkbox" id="check2019"> <label for="check2019">2019</label><br>
			<input type="checkbox" id="check2018"> <label for="check2018">2018</label><br>
			<input type="checkbox" id="check2017"> <label for="check2017">2017</label><br>
			<input type="checkbox" id="check2016"> <label for="check2016">2016</label><br>
			<input type="checkbox" id="check2015"> <label for="check2015">2015</label><br>
			<select id='severity'>
				<option value='Any'>Any</option>

				<option value='Fatality'>Fatality</option>

				<option value='Injury'>Injury</option>

				<option value='NonInjury'>Non-Injury</option>
			</select>

			<select id="selectStreet">
				<option>Any</option>

			</select>

			<div id='summary'></div>

			<button id="filterButton">Filter collisions</button>

			<div><canvas id="crashHist"></canvas></div>
			<div><canvas id="crashFaultHist"></canvas></div>
		</div>
		<div id="osm-map"></div>
	</div>
	<script src="https://unpkg.com/chart.js@4.2.0/dist/chart.umd.js"></script>

	

	<script type="module">
		import { collisionsJson, transparencyJson, mergedTransparencyJson } from "./js/util.js";


		/*const checkBike = document.querySelector('#checkBike');
		const checkCar = document.querySelector('#checkCar');
		const checkPed = document.querySelector('#checkPed');
		const checkTruck = document.querySelector('#checkTruck');
		const checkParked = document.querySelector('#checkParked');
		const checkMotorcycle = document.querySelector('#checkMotorcycle');
		const checkBus = document.querySelector('#checkBus');
		const checkElectricScooter = document.querySelector('#checkElectricScooter'); */

		const selectVehicleTypes = document.querySelector('#selectVehicleTypes');

		const check2024 = document.querySelector('#check2024');
		const check2023 = document.querySelector('#check2023');
		const check2022 = document.querySelector('#check2022');
		const check2021 = document.querySelector('#check2021');
		const check2020 = document.querySelector('#check2020');

		const check2019 = document.querySelector('#check2019');
		const check2018 = document.querySelector('#check2018');
		const check2017 = document.querySelector('#check2017');
		const check2016 = document.querySelector('#check2016');
		const check2015 = document.querySelector('#check2015');


		const selectStreet = document.querySelector('#selectStreet');
		const selectSeverity = document.querySelector('#severity');

		const summary = document.querySelector('#summary');





		// Where you want to render the map.
		var element = document.getElementById('osm-map');
		// Height has to be set. You can do this in CSS too.
		element.style = 'height:100vh;';
		// Create Leaflet map on map element.
		var map = L.map(element);
		// Add OSM tile layer to the Leaflet map.
		L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
			attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
		}).addTo(map);
		// Target's GPS coordinates.
		var target = L.latLng('37.87', '-122.27'); // berkeley 37°52′18″N 122°16′22″W
		// Set map's center to target with zoom 14.
		map.setView(target, 14);
		// add geojson precincts to map

		const bikeIcon = L.icon({ iconUrl: './test/bicycle.png' });
		const pedIcon = L.icon({ iconUrl: './test/pedestrian.png' });
		const carIcon = L.icon({ iconUrl: './test/suv.png' });

		function randomOffset() {
			const r = Math.random() - 0.5;
			return r / 5000;
		}
		function objToString(obj) {
			var msg = "";

			for (const [key, value] of Object.entries(obj)) {
				msg += ('<br>' + key + ':' + value);
			}
			return msg;
		}

		const popupFields = ['Date',
			'Time',
			'Day_of_Week',
			'Case_Number',
			'Accident_Location',
			'Latitude',
			'Longitude',
			'Collision_Classification_Descri',
			'Collision_Type',
			'Primary_Collision_Factor_Code',
			'PCF_Description',
			'PCF_Category',
			'Involved_Objects',
			'Involved_Parties',
			'Party_at_Fault',
			'Number_of_Injuries',
			'Number_of_Fatalities',
			'Suspected_Serious_Injury'
		];
		function collisionPopup(obj) {
			var msg = "";
			for (const k of popupFields) {
				const v = obj[k];
				if (v) {
					msg += (k + ': ' + v + '<br>');
				}
			}
			return msg;
		}

		// populate the street select options
		function populateStreetSelect(mergedTransparencyJson, selectStreet) {
			const setStreets = new Set();

			for (const coll of mergedTransparencyJson) {
				const attr = coll.attributes;
				const loc = attr.Accident_Location;
				const arr = loc.split("/");
				for (const str of arr) {
					setStreets.add(str);
				}
			}

			// sort
			const arrSorted = Array.from(setStreets).sort();
			//	console.debug("Streetnames")
			for (const str of arrSorted) {
				//		console.debug(str);
				const opt = document.createElement("option");
				opt.text = str;
				selectStreet.add(opt, null);
			}
		}
		populateStreetSelect(mergedTransparencyJson, selectStreet);

		// keep track of markes for removal
		const markers = [];

		function removeAllMakers() {
			for (const m of markers) {
				m.remove();
			}
		}

		function checkFilter(attr, vehTypeRegExp, /* filterBike, filterCar, filterPed, filterTruck,
			filterParked, filterBus, filterMotorcycle,
			filterElectricScooter, */
			filter2024, filter2023,
			filter2022, filter2021, filter2020,
			filter2019,
			filter2018,
			filter2017,
			filter2016,
			filter2015,

			selectStreet, severity
		) {
			const involved = attr.Involved_Objects;

			const m = involved.match(vehTypeRegExp);

			if (!m) {
				return false;
			}
			/*if (involved.includes("Bi") != filterBike) {
				return false;
			}
			if (involved.includes("Ped") != filterPed) {
				return false;
			}
			if (involved.includes("Car") != filterCar) {
				return false;
			}

			if (involved.includes("Truck") != filterTruck) {
				return false;
			}
			if (involved.includes("Park") != filterParked) {
				return false;
			}
			if (involved.includes("Motor") != filterMotorcycle) {
				return false;
			}
			if (involved.includes("Bus") != filterBus) {
				return false;
			}
			if (involved.includes("Electric Scooter") != filterElectricScooter) {
				return false;
			}*/



			const year = attr.Year;
			if ((year == 2024) && !filter2024) {
				return false;

			}
			if ((year == 2023) && !filter2023) {
				return false;

			}
			if ((year == 2022) && !filter2022) {
				return false;

			}
			if ((year == 2021) && !filter2021) {
				return false;

			}
			if ((year == 2020) && !filter2020) {
				return false;

			}
			if ((year == 2019) && !filter2019) {
				return false;

			}
			if ((year == 2018) && !filter2018) {
				return false;

			}
			if ((year == 2017) && !filter2017) {
				return false;

			}
			if ((year == 2016) && !filter2016) {
				return false;

			}
			if ((year == 2015) && !filter2015) {
				return false;

			}
			if ((year < 2015) || (year > 2024)) {
				return false;
			}
			const loc = attr.Accident_Location;

			if (selectStreet != "Any") {
				if (!loc.includes(selectStreet)) {
					return false;
				}

			}
			if (severity == 'Fatality') {
				if (attr.Number_of_Fatalities == 0) {
					return false;
				}
			}
			if (severity == 'Injury') {
				if (attr.Number_of_Injuries == 0) {
					return false;
				}
			}
			if (severity == 'NonInjury') {
				if ((attr.Number_of_Injuries != 0) || (attr.Number_of_Fatalities != 0)) {
					return false;
				}
			}
			return true;
		}

		var greenIcon = new L.Icon({
			iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
			shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
			iconSize: [25, 41],
			iconAnchor: [12, 41],
			popupAnchor: [1, -34],
			shadowSize: [41, 41]
		});

		var goldIcon = new L.Icon({
			iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-gold.png',
			shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
			iconSize: [25, 41],
			iconAnchor: [12, 41],
			popupAnchor: [1, -34],
			shadowSize: [41, 41]
		});

		var redIcon = new L.Icon({
			iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
			shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
			iconSize: [25, 41],
			iconAnchor: [12, 41],
			popupAnchor: [1, -34],
			shadowSize: [41, 41]
		});

		function addMarkers(collisionJson, histData, histFaultData, /*filterBike, filterCar, filterPed,
			filterTruck, filterParked, filterMotorcycle, filterBus, filterElectricScooter, */
			vehTypeRegExp,
			filter2024, filter2023, filter2022, filter2021, filter2020,

			filter2019,
			filter2018,
			filter2017,
			filter2016,
			filter2015,

			selectStreet, selectSeverity

		) {
			removeAllMakers();
			const markersAtLocation = new Map();
			// add collisions to map
			var markerCount = 0
			var skipped = 0, plotted = 0;

			for (const coll of collisionJson) {
				const attr = coll.attributes;
				/*if (!attr.Accident_Location.includes('Fulton')) {
					skipped++;
					continue;
				}*/
				const checked = checkFilter(attr, vehTypeRegExp, /*filterBike, filterCar, filterPed,
					filterTruck, filterParked, filterBus, filterMotorcycle, filterElectricScooter,*/
					filter2024, filter2023, filter2022, filter2021, filter2020,
					filter2019,
					filter2018,
					filter2017,
					filter2016,
					filter2015,

					selectStreet, selectSeverity);
				if (!checked) {
					continue;
				}
				plotted++;
				histData.set(attr.Year, histData.get(attr.Year) + 1);

				histFaultData.set( attr.Party_at_Fault, histFaultData.get(attr.Party_at_Fault) + 1);

				if (attr.Latitude && attr.Longitude) {
					const loc = [attr.Latitude, attr.Longitude];
					const roundLoc = loc.map((c) => c.toFixed(3));
					const ct = markersAtLocation.get(JSON.stringify(loc)) ?? 0;

					if (ct > 0) {
						console.log("adjusting marker")
					}

					var myMarker;
					if (attr.Number_of_Fatalities > 0) {
						myMarker = redIcon;
					} else if (attr.Number_of_Injuries > 0) {
						myMarker = goldIcon
					} else {
						myMarker = greenIcon;
					}
					const marker = L.marker([attr.Latitude + ct * 0.0001, attr.Longitude - ct * 0.0001],
						{ icon: myMarker });
					markersAtLocation.set(JSON.stringify(loc), ct + 1);
					const msg = collisionPopup(attr);
					marker.bindPopup(msg).openPopup();
					marker.addTo(map);
					markers.push(marker);
					markerCount++;
				}
			}
			console.log('Skipped', skipped);
			console.log('Plotted', plotted);
			console.log("markerCount ", markerCount)

			const summaryMsg = '<br>Matching collsions: ' + plotted;//+ '<br>' + 'Skipped: ' + skipped + '<br>';
			summary.innerHTML = summaryMsg;


		}
		map.setView(target, 14);
		//	addMarkers(mergedTransparencyJson, true, true, true, true, true, true, true, true);

		const histData = new Map();
		function clearHistData() {
			for (var y = 2015; y < 2025; y++) {
				histData.set(y, 0);
			}
		}
		clearHistData();
		var histChart;

		var histFaultData = new Map();
		const faultKeys = [
			"Bicyclist",
			"Driver",
			"Object",
			"Other",
			"Pedestrian"
		];

		function clearFaultData() {
			for (const f of faultKeys) {
				histFaultData.set(f,0);
			}
		}
		clearFaultData();
		var histFaultChart;

		document.querySelector('#filterButton').addEventListener('click', (event) => {
			clearHistData();
			clearFaultData();
			addMarkers(mergedTransparencyJson, histData,histFaultData,
				/*
					checkBike.checked,
					checkCar.checked,
					checkPed.checked,
					checkTruck.checked,
					checkParked.checked,
					checkMotorcycle.checked,
					checkBus.checked,
					checkElectricScooter.checked, */
				selectVehicleTypes.value,

				check2024.checked,
				check2023.checked,
				check2022.checked,
				check2021.checked,
				check2020.checked,

				check2019.checked,
				check2018.checked,
				check2017.checked,
				check2016.checked,
				check2015.checked,



				selectStreet.value,
				selectSeverity.value


			);
// make fault histo
            console.dir(histFaultData);

			(function () {
				const data = [];
				for (const k of faultKeys) {
					data.push( {party:k, count: histFaultData.get(k)})
				}
				if (histFaultChart == undefined) {
					histFaultChart = new Chart(
						document.getElementById('crashFaultHist'),
						{
							type: 'bar',
							data: {
								labels: data.map(row => row.party),
								datasets: [
									{
										label: 'matching crashes by fault',
										data: data.map(row => row.count)
									}
								]
							}
						}
					);
				} else {
					//const newData = data.map(row => row.count);
					// update data

					const newData = {
						label: 'matching crashes by fault',
						data: data.map(row => row.count)
					}

					histFaultChart.data.datasets.pop();
					histFaultChart.data.datasets.push(newData);
					console.log(newData);
					histFaultChart.update();
				}
			})();

			console.dir(histData);

			(function () {
				const data = [
					{ year: 2015, count: histData.get(2015) },
					{ year: 2016, count: histData.get(2016) },
					{ year: 2017, count: histData.get(2017) },
					{ year: 2018, count: histData.get(2018) },
					{ year: 2019, count: histData.get(2019) },
					{ year: 2020, count: histData.get(2020) },
					{ year: 2021, count: histData.get(2021) },
					{ year: 2022, count: histData.get(2022) },
					{ year: 2023, count: histData.get(2023) },
					{ year: 2024, count: histData.get(2024) },

				];
				if (histChart == undefined) {
					histChart = new Chart(
						document.getElementById('crashHist'),
						{
							type: 'bar',
							data: {
								labels: data.map(row => row.year),
								datasets: [
									{
										label: 'matching crashes by year',
										data: data.map(row => row.count)
									}
								]
							}
						}
					);
				} else {
					//const newData = data.map(row => row.count);
					// update data

					const newData = {
						label: 'matching crashes by year',
						data: data.map(row => row.count)
					}

					histChart.data.datasets.pop();
					histChart.data.datasets.push(newData);
					console.log(newData);
					histChart.update();
				}
			})();




		});




	</script>
</body>